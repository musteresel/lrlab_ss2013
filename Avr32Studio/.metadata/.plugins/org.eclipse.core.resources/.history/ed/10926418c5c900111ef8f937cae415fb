/*
 * system.c
 */
//==============================================================================
/** Include directives */
#include "board.h"
#include "compiler.h"
#include "intc.h"
#include "stdio.h"
#include "pm.h"
#include "LR_ringbuffer.h"
#include "LR_usart.h"
#include "LR_display.h"
#include "LR_timer.h"
#include "LR_adc.h"
#include "math.h"
#include "LR_pwm.h"
#include "gpio.h"
#include <avr32/io.h>




//==============================================================================
/** State descriptions */
#define SYS_STATE_STA 1
#define SYS_STATE_SEN 2
#define SYS_STATE_CAL 3
#define SYS_STATE_ANG 4
#define SYS_STATE_CON 5
#define SYS_STATE_SET 6

#define SYS_IN_STATE 0
#define SYS_ENTER_STATE 1
#define SYS_LEAVE_STATE 2




//==============================================================================
/** Command word definitions */
#define CMD_CON (('C' << 24) | ('O' << 16) | ('N' << 8) | 0)
#define CMD_ANG (('A' << 24) | ('N' << 16) | ('G' << 8) | 0)
#define CMD_CAL (('C' << 24) | ('A' << 16) | ('L' << 8) | 0)
#define CMD_SEN (('S' << 24) | ('E' << 16) | ('N' << 8) | 0)
#define CMD_STA (('S' << 24) | ('T' << 16) | ('A' << 8) | 0)
#define CMD_SET (('S' << 24) | ('E' << 16) | ('T' << 8) | 0)
#define CMD_ACK (('A' << 24) | ('C' << 16) | ('K' << 8) | 0)




//==============================================================================
/** State machine state */
typedef struct
{
  int cur;
  int prev;
  int next;
  signed char move;
}State;




//==============================================================================
//** Global variables */
LR_ringbuffer rb_usart;
#define RB_USART_SIZE 80
int __rb_usart[RB_USART_SIZE];
avr32_pwm_channel_t pwm_channel = { .ccnt = 0 };
LR_pwm pwm;
volatile double calib_x = 896.397000;
volatile double calib_y;
volatile double calib_z;
volatile double sens_max;
volatile double sens_min;
volatile double sens = 56.294500;

volatile double pwm_freq = 10;
volatile double pwm_duty = 0;

volatile double con_P = 0;
volatile double con_I = 0;
volatile double con_D = 0;

volatile double con_Desired = 0;
volatile double con_Integral = 0;
volatile double con_lastE = 0;

//==============================================================================
/** Display update handler
 *
 * This function is called periodically to update the display.
 */
__attribute__((__interrupt__))
static void display_handler(void)
{
  static int n = 0;
  if (n < 100)
  {
    n++;
  }
  else
  {
    n = 0;
    static unsigned char i = 1;
    dip204_set_cursor_position(1,2);
    dip204_write_string("                    ");
    dip204_set_cursor_position(i,2);
    dip204_write_string("+");
    dip204_set_cursor_position(1,3);
    i = i + 1;
    if (i > 20)
    {
      i = 1;
    }
  }
  LR_timer_sti(0);
}



//==============================================================================
/** CON handler
 *
 * This function is the controller of the closed loop control system
 */
__attribute__((__interrupt__))
void con_handler(void)
{
  // Read angle
  double ang = 0;
  LR_adc_start();
  ang = (LR_adc_get(5) - calib_x) / sens;
  ang = asin(ang) * (180. /3.14);
  // TODO: FILTER
  //----------------------------------------------------------------------------
  double U = 0;
  double e = con_Desired - ang;

  // Proportional part
  U = con_P * e;

  // Integral part
  con_Integral += 10 * e * con_I;
  U += con_Integral;


  // Derivative part
  double derived = e - con_lastE;
  if (derived != 0)
  {
    U += derived / 10.;
  }

  //----------------------------------------------------------------------------
  // Staturation function
  if (U > 100)
  {
    U = 100;
  }
  else if (U < -100)
  {
    U = -100;
  }

  //----------------------------------------------------------------------------
  // Negative to AIN*
  if (U < 0)
  {
    gpio_set_gpio_pin(AVR32_PIN_PC04);
    gpio_clr_gpio_pin(AVR32_PIN_PC05);
    U *= -1;
  }
  else
  {
    gpio_set_gpio_pin(AVR32_PIN_PC05);
    gpio_clr_gpio_pin(AVR32_PIN_PC04);
  }

  // Update duty
  char string[80];
  sprintf(string,"ANG: %f   E: %f   U: %f\n",ang,e,U);
  LR_usart_write(string);
  static int test = 0;
  LR_pwm_update_duty(&pwm, test/100.);
  test++;
  if (test >= 100) test = 0;
  //----------------------------------------------------------------------------
  LR_timer_sti(1);
}





//==============================================================================
/** ANG handler
 *
 * This function writes the current angle to the USART.
 */
__attribute__((__interrupt__))
void ang_handler(void)
{
  // Read angle
  double ang = 0;
  LR_adc_start();
  ang = (LR_adc_get(5) - calib_x) / sens;
  ang = asin(ang) * (180./3.14);
  char string[30];
  sprintf(string,"ANG: %f\n",ang);
  LR_usart_write(string);
  LR_timer_sti(1);
}




//==============================================================================
/** Calibration handler.
 *
 * This function reads 1000 samples to calibrate the zero angle position of the
 * sensor.
 */
__attribute__((__interrupt__))
void cal_handler(void)
{
  static unsigned short n = 0;
  static unsigned long x = 0;
  static unsigned long y = 0;
  static unsigned long z = 0;
  if (n < 1000)
  {
    LR_adc_start();
    x += LR_adc_get(5);
    y += LR_adc_get(6);
    z += LR_adc_get(7);
    n++;
  }
  else
  {
    LR_timer_stop(1);
    n = 0;
    calib_x = x / 1000.;
    calib_y = y / 1000.;
    calib_z = z / 1000.;
    x = 0;
    y = 0;
    z = 0;
  }
  LR_timer_sti(1);
}



//==============================================================================
/** Read the max sensor value */
__attribute__((__interrupt__))
void sens_max_handler(void)
{
  static unsigned short n = 0;
  static unsigned long val = 0;
  if (n < 1000)
  {
    LR_adc_start();
    val += LR_adc_get(5);
    n++;
  }
  else
  {
    LR_timer_stop(1);
    n = 0;
    sens_max = val / 1000.;
    val = 0;
  }
  LR_timer_sti(1);
}




//==============================================================================
/** Read the min sensor value */
__attribute__((__interrupt__))
void sens_min_handler(void)
{
  static unsigned short n = 0;
  static unsigned long val = 0;
  if (n < 1000)
  {
    LR_adc_start();
    val += LR_adc_get(5);
    n++;
  }
  else
  {
    LR_timer_stop(1);
    n = 0;
    sens_min = val / 1000.;
    val = 0;
  }
  LR_timer_sti(1);
}




//==============================================================================
/** Wait to receive a command word via USART
 *
 * This function gets called after the state dependend operations are finished
 * and waits for a new command word via USART.
 */
int wait_cmd()
{
  int s = -1;
  int c = 0;
  unsigned int cmd = 0;
  unsigned char received = 0;
  while (s == -1)
  {
    if (LR_ringbuffer_get(&rb_usart, &c))
    {
      cmd |= (0xFF & c) << ( 8 * (3 - received) );
      received++;
      if (received == 3)
      {
        cmd = cmd & 0xFFFFFF00;
        if (cmd == CMD_CON)
        {
          s = SYS_STATE_CON;
        }
        else if (cmd == CMD_ANG)
        {
          s = SYS_STATE_ANG;
        }
        else if (cmd == CMD_CAL)
        {
          s = SYS_STATE_CAL;
        }
        else if (cmd == CMD_SEN)
        {
          s = SYS_STATE_SEN;
        }
        else if (cmd == CMD_STA)
        {
          s = SYS_STATE_STA;
        }
        else if (cmd == CMD_SET)
        {
          s = SYS_STATE_SET;
        }
        if (s == -1)
        {
          LR_usart_write("NACK\n");
          cmd = 0;
          received = 0;
        }
        else
        {
          LR_usart_write("ACK\n");
        }
      }
    }
  }
  return s;
}



//==============================================================================
/** Wait to receive an ACK via USART.
 *
 * This function waits until it received ACK via USART.
 */
void wait_ack()
{
  signed char s = -1;
  int c = 0;
  unsigned int cmd = 0;
  unsigned char received = 0;
  while (s == -1)
  {
    if (LR_ringbuffer_get(&rb_usart, &c))
    {
      cmd |= (0xFF & c) << ( 8 * (3 - received) );
      received++;
      if (received == 3)
      {
        cmd = cmd & 0xFFFFFF00;
        if (cmd == CMD_ACK)
        {
          s = 1;
        }
        else
        {
          LR_usart_write("ACK?\n");
          cmd = 0;
          received = 0;
        }
      }
    }
  }
}



//==============================================================================
/** Die function
 *
 * This function gets called when something goes terribly wrong inside the
 * state machine. It just prints a error message through USART and then
 * loops for ever (Disables interrupts).
 */
__attribute__((noreturn))
void state_machine_die()
{
  LR_usart_write("ERROR: State Machine died!\n");
  while (1) Disable_global_interrupt();
}




//==============================================================================
/** Generic state enter function */
void state_machine_enter(State * state)
{
  state->move = SYS_IN_STATE;
  char string[20];
  sprintf(string, "ENTER: %d\n",state->cur);
  LR_usart_write(string);
}
/** Generic state change function */
void state_machine_change(State * state)
{
  state->move = SYS_LEAVE_STATE;
}
/** Generic state leave function */
void state_machine_leave(State * state)
{
  state->move = SYS_ENTER_STATE;
  char string[20];
  sprintf(string, "LEAVE: %d\n",state->cur);
  LR_usart_write(string);
  state->prev = state->cur;
  state->cur = state->next;
}




//==============================================================================
/** Main loop function
 *
 * This function contains the main code of the system, which will be executed
 * after system setup until loss of power.
 * This includes usart parsing, state control and general code to maintain
 * the system at runtime.
 */
__attribute__((noreturn))
void main_loop( void )
{
  /** state etc */
  State state;
  state.cur = SYS_STATE_STA;
  state.prev = SYS_STATE_STA;
  state.next = SYS_STATE_STA;
  state.move = SYS_ENTER_STATE;

  while(1)
  {
    //oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooCON
    if (state.cur == SYS_STATE_CON)
    {
      /** Actions which belong to the control state */
      //-----------------------------------------------------------------------I
      if (state.move == SYS_IN_STATE)
      {
        // TODO
        // activate PID controller
        int s = wait_cmd();
        if (s == SYS_STATE_SET)
        {
          // read new parameter
        }
        else if (s != state.cur)
        {
          state.next = s;
          state_machine_change(&state);
        }
      }
      //-----------------------------------------------------------------------E
      else if (state.move == SYS_ENTER_STATE)
      {
        state_machine_enter(&state);
        LR_pwm_start(&pwm, pwm_freq, pwm_duty, FOSC0);
        LR_timer_assign(1, con_handler, 10);
        LR_timer_start(1);
      }
      //-----------------------------------------------------------------------L
      else if (state.move == SYS_LEAVE_STATE)
      {
        LR_pwm_stop(&pwm);
        LR_timer_stop(1);
        state_machine_leave(&state);
      }
      //-----------------------------------------------------------------------D
      else
      {
        /** Actions when state move failed */
        state_machine_die();
      }
    }
    //oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooANG
    else if (state.cur == SYS_STATE_ANG)
    {
      /** Actions which belong to the angle measure state */
      //-----------------------------------------------------------------------I
      if (state.move == SYS_IN_STATE)
      {
        LR_timer_assign(1,ang_handler,500);
        LR_timer_start(1);
        int s = wait_cmd();
        if (s != state.cur)
        {
          state.next = s;
          state_machine_change(&state);
        }
      }
      //-----------------------------------------------------------------------E
      else if (state.move == SYS_ENTER_STATE)
      {
        state_machine_enter(&state);
      }
      //-----------------------------------------------------------------------L
      else if (state.move == SYS_LEAVE_STATE)
      {
        LR_timer_stop(1);
        state_machine_leave(&state);
      }
      //-----------------------------------------------------------------------D
      else
      {
        /** Actions when state move failed */
        state_machine_die();
      }
    }
    //oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooCAL
    else if (state.cur == SYS_STATE_CAL)
    {
      /** Actions which belong to the calibration state */
      //-----------------------------------------------------------------------I
      if (state.move == SYS_IN_STATE)
      {
        LR_usart_write("Sensor at 0g X, 0g Y, -1g Z Position?\n");
        wait_ack();
        LR_timer_assign(1,cal_handler,10);
        LR_timer_start(1);
        LR_timer_wait(1);
        char string[40];
        sprintf(string,"VxOffset: %f\n",calib_x);
        LR_usart_write(string);
        wait_ack();
        state.next = state.prev;
        state_machine_change(&state);
      }
      //-----------------------------------------------------------------------E
      else if (state.move == SYS_ENTER_STATE)
      {
        state_machine_enter(&state);
        // TODO on enter
      }
      //-----------------------------------------------------------------------L
      else if (state.move == SYS_LEAVE_STATE)
      {
        // TODO on leave
        state_machine_leave(&state);
      }
      //-----------------------------------------------------------------------D
      else
      {
        /** Actions when state move failed */
        state_machine_die();
      }
    }
    //oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooSEN
    else if (state.cur == SYS_STATE_SEN)
    {
      /** Actions which belong to the sensivity measure state */
      //-----------------------------------------------------------------------I
      if (state.move == SYS_IN_STATE)
      {
        // TODO
        LR_usart_write("X-Axis at +1g Position?\n");
        wait_ack();
        // read v
        LR_timer_assign(1, sens_max_handler, 10);
        LR_timer_start(1);
        LR_timer_wait(1);
        char string[40];
        sprintf(string,"VxMax: %f\n", sens_max);
        LR_usart_write(string);
        wait_ack();
        LR_usart_write("X-Axis at -1g Position?\n");
        wait_ack();
        // read v
        LR_timer_assign(1,sens_min_handler, 10);
        LR_timer_start(1);
        LR_timer_wait(1);
        sprintf(string,"VxMin: %f\n",sens_min);
        LR_usart_write(string);
        wait_ack();
        sens = (sens_max - sens_min) / 2.;
        sprintf(string,"Sensivity: %f\n", sens);
        LR_usart_write(string);
        wait_ack();
        state.next = state.prev;
        state_machine_change(&state);
      }
      //-----------------------------------------------------------------------E
      else if (state.move == SYS_ENTER_STATE)
      {
        state_machine_enter(&state);
        // TODO on enter
      }
      //-----------------------------------------------------------------------L
      else if (state.move == SYS_LEAVE_STATE)
      {
        // TODO on leave
        state_machine_leave(&state);
      }
      //-----------------------------------------------------------------------D
      else
      {
        /** Actions when state move failed */
        state_machine_die();
      }
    }
    //oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooSTA
    else if (state.cur == SYS_STATE_STA)
    {
      /** Actions which belong to the standby state */
      //-----------------------------------------------------------------------I
      if (state.move == SYS_IN_STATE)
      {
        // TODO
        int s = wait_cmd();
        if (s != state.cur)
        {
          state.next = s;
          state_machine_change(&state);
        }
      }
      //-----------------------------------------------------------------------E
      else if (state.move == SYS_ENTER_STATE)
      {
        state_machine_enter(&state);
        // TODO on enter
      }
      //-----------------------------------------------------------------------L
      else if (state.move == SYS_LEAVE_STATE)
      {
        // TODO on leave
        state_machine_leave(&state);
      }
      //-----------------------------------------------------------------------D
      else
      {
        /** Actions when state move failed */
        state_machine_die();
      }
    }
    //oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooDIE
    else
    {
      /** Actions to take when the state machine fails */
      state_machine_die();
    }
  }
}





//==============================================================================
/** Main function to setup system state
 *
 * This function is called upon start and used to setup all required hardware
 * and components.
 */
int main ( void )
{
  /** Switch the oscilator */
  pm_switch_to_osc0( &AVR32_PM, FOSC0, OSC0_STARTUP);

  /** Setupt interrupts, handlers will be added later by the various system
   * components.
   */
  Disable_global_interrupt();
  INTC_init_interrupts();
  Enable_global_interrupt();

  /** Activate the display */
  LR_display_init( FOSC0 );

  /** Init the ringbuffers */
  LR_ringbuffer_init( &rb_usart, __rb_usart, RB_USART_SIZE);
  // TODO

  /** Init the usart inteface */
  LR_usart_init( FOSC0, &rb_usart);

  /** Init timer counters */
  LR_timer_init(0,FOSC0);
  LR_timer_init(1,FOSC0);

  /** Set a timer to write to the display */
  LR_timer_assign(0,display_handler,5);
  LR_timer_start(0);

  /** Configure ADC */
  LR_adc_init_channel(5);
  LR_adc_init_channel(6);
  LR_adc_init_channel(7);
  LR_adc_init();
  LR_adc_enable_channel(5);
  LR_adc_enable_channel(6);
  LR_adc_enable_channel(7);

  /** Init pwm */
  pwm.chan = &(pwm_channel);
  gpio_enable_module_pin(AVR32_PIN_PB19, 0); // PWM out
  gpio_enable_module_pin(AVR32_PIN_PC04, 0); // AIN1
  gpio_enable_module_pin(AVR32_PIN_PC05, 0); // AIN2
  gpio_set_gpio_pin(AVR32_PIN_PC04);
  gpio_clr_gpio_pin(AVR32_PIN_PC05);
  LR_pwm_init();
  LR_pwm_start(&pwm, 1000, .50, FOSC0);


  /** Enter the main loop */
  main_loop( );
  return 0;
}


// VCC3 -> Sensor VCC
// GND  -> Sensor GND

// PA26 -> X
// PA27 -> Y
// PA28 -> Z

// PB19 -> PWMA
// PC04 -> AIN1
// PC05 -> AIN2
